// StandardFrequentistDiscoveryImpSampl

/*
 StandardFrequentistDiscoveryImpSampl
 based on StandardFrequentistDiscovery

 Author: Sven Kreiss, Kyle Cranmer
 date: Jan. 2012

 This is a standard demo that can be used with any ROOT file
 prepared in the standard way.  You specify:
 - name for input ROOT file
 - name of workspace inside ROOT file that holds model and data
 - name of ModelConfig that specifies details for calculator tools
 - name of dataset

 With default parameters the macro will attempt to run the
 standard hist2workspace example and read the ROOT file
 that it produces.
 */

#include "TFile.h"
#include "TROOT.h"
#include "TH1F.h"
#include "TF1.h"
#include "TCanvas.h"
#include "TStopwatch.h"

#include "RooWorkspace.h"
#include "RooAbsData.h"
#include "RooRandom.h"
#include "RooRealSumPdf.h"
#include "RooNumIntConfig.h"
#include "RooAbsDataStore.h"

#include "RooStats/ModelConfig.h"
#include "RooStats/ToyMCImportanceSampler.h"
#include "RooStats/HypoTestResult.h"
#include "RooStats/HypoTestPlot.h"
#include "RooStats/SamplingDistribution.h"
#include "RooStats/ProfileLikelihoodTestStat.h"
#include "RooStats/SimpleLikelihoodRatioTestStat.h"
#include "RooStats/ProfileLikelihoodCalculator.h"
#include "RooStats/LikelihoodInterval.h"
#include "RooStats/LikelihoodIntervalPlot.h"

#include "RooStats/FrequentistCalculator.h"

#include <vector>

using namespace RooFit;
using namespace RooStats;






ToyMCSampler* configureToyMCSampler(ModelConfig* /*mc*/, RooAbsData* /*data*/, TestStatistic* ts) {
   return new ToyMCSampler(*ts, 50);
}


ToyMCImportanceSampler* configureToyMCImportanceSampler(ModelConfig* mc, RooAbsData* data, TestStatistic* ts, int impPoints, bool adaptiveNumImpPoints) {
   // ----------------------------------------------------
   // configure the ToyMCImportanceSampler
   ToyMCImportanceSampler* toymcs = new ToyMCImportanceSampler(*ts, 50);
   
   // use more toys for importance densities with larger mu
   //toymcs->SetExpIncreasingNumToysPerDensity();
   // or not:
   toymcs->SetEqualNumToysPerDensity();

   // ----------------------------------------------------
   // get muhat
   RooArgSet* allParams = mc->GetPdf()->getParameters(*data);
   mc->GetPdf()->fitTo( *data, PrintLevel(-1), SumW2Error(kFALSE), Constrain(*allParams) );
   delete allParams;

   RooRealVar* firstPOI = (RooRealVar*) mc->GetParametersOfInterest()->first();
   double fitFavoredMu = firstPOI->getVal();
   cout << "fit favored mu: " << fitFavoredMu << endl;
   firstPOI->Print();

   // ----------------------------------------------------
   // create the importance densities to use
   int numImpSnaps = 0;
   if( adaptiveNumImpPoints ) {
      numImpSnaps = toymcs->CreateImpDensitiesForOnePOIAdaptively( *mc->GetPdf(), *mc->GetParametersOfInterest(), *firstPOI, 0.5 );
      //numImpSnaps = toymcs->CreateImpDensitiesForOnePOIAdaptively( *mc->GetPdf(), *mc->GetParametersOfInterest(), *firstPOI, 0.5, 0.0, mc->GetNuisanceParameters() );
   }else{
      numImpSnaps = toymcs->CreateNImpDensitiesForOnePOI( *mc->GetPdf(), *mc->GetParametersOfInterest(), *firstPOI, impPoints );
      //numImpSnaps = toymcs->CreateNImpDensitiesForOnePOI( *mc->GetPdf(), *mc->GetParametersOfInterest(), *firstPOI, impPoints, 0.0, mc->GetNuisanceParameters() );
   }

   return toymcs;
}




double StandardFrequentistDiscoveryImportanceSampling(
   const char* infile = "",
   const char* workspaceName = "channel1",
   const char* modelConfigNameSB = "ModelConfig",
   const char* dataName = "obsData",
   const char* ofile = "ToysOutput.root",
   int impPoints = 1,
   bool adaptiveNumImpPoints = false,
   int toys = 10000,
   double poiValueForBackground = 0.0,
   double poiValueForSignal = 1.0
) {

   RooAbsReal::defaultIntegratorConfig()->method1D().setLabel("RooAdaptiveGaussKronrodIntegrator1D") ;
   ROOT::Math::MinimizerOptions::SetDefaultMinimizer("Minuit2");
   
   // The workspace contains the model for s+b. The b model is "autogenerated"
   // by copying s+b and setting the one parameter of interest to zero.
   // To keep the script simple, multiple parameters of interest or different
   // functional forms of the b model are not supported.

   // for now, assume there is only one parameter of interest, and these are
   // its values:

   /////////////////////////////////////////////////////////////
   // First part is just to access a user-defined file
   // or create the standard example file if it doesn't exist
   ////////////////////////////////////////////////////////////
   const char* filename = "";
   if (!strcmp(infile, "")) filename = "results/example_channel1_GaussExample_model.root";
   else filename = infile;
   // Check if example input file exists
   TFile *file = TFile::Open(filename);

   // if input file was specified but not found, quit
   if (!file && strcmp(infile, "")) {
      cout << "file not found" << endl;
   }

   // if default file not found, try to create it
   if (!file) {
      // Normally this would be run on the command line
      cout << "will run standard hist2workspace example" << endl;
      gROOT->ProcessLine(".! prepareHistFactory .");
      gROOT->ProcessLine(".! hist2workspace config/example.xml");
      cout << "\n\n---------------------" << endl;
      cout << "Done creating example input" << endl;
      cout << "---------------------\n\n" << endl;
   }

   // now try to access the file again
   file = TFile::Open(filename);
   if (!file) {
      // if it is still not there, then we can't continue
      cout << "Not able to run hist2workspace to create example input" << endl;
      return -1.0;
   }

   /////////////////////////////////////////////////////////////
   // Tutorial starts here
   ////////////////////////////////////////////////////////////

   TStopwatch *mn_t = new TStopwatch;
   mn_t->Start();

   // get the workspace out of the file
   RooWorkspace* w = (RooWorkspace*) file->Get(workspaceName);
   if (!w) {
      cout << "workspace not found" << endl;
      return -1.0;
   }

   // get the modelConfig out of the file
   ModelConfig* mc = (ModelConfig*) w->obj(modelConfigNameSB);

   // get the data out of the file
   RooAbsData* data = w->data(dataName);

   // make sure ingredients are found
   if (!data || !mc) {
      w->Print();
      cout << "data or ModelConfig was not found" << endl;
      return -1.0;
   }


   RooRealVar* firstPOI = (RooRealVar*) mc->GetParametersOfInterest()->first();
   firstPOI->setRange( -10,10 );
   // set snapshot for alt
   firstPOI->setVal(poiValueForSignal);
   mc->SetSnapshot(*mc->GetParametersOfInterest());
   // create null model
   ModelConfig *mcNull = mc->Clone("ModelConfigNull");
   firstPOI->setVal(poiValueForBackground);
   mcNull->SetSnapshot(*(RooArgSet*)mcNull->GetParametersOfInterest()->snapshot());



   // ----------------------------------------------------
   // Configure a ProfileLikelihoodTestStat and a SimpleLikelihoodRatioTestStat
   // to use simultaneously with ToyMCSampler
   ProfileLikelihoodTestStat* plts =  new ProfileLikelihoodTestStat(*mc->GetPdf());
   plts->SetOneSidedDiscovery(true);
   plts->SetSigned(true);
   plts->SetVarName( "q_{0}/2" );
   plts->EnableDetailedOutput( true );

   SimpleLikelihoodRatioTestStat* slrts = new SimpleLikelihoodRatioTestStat(*mc->GetPdf(),*mc->GetPdf());
   slrts->EnableDetailedOutput( true );
   slrts->SetNullParameters( *mcNull->GetSnapshot() );
   slrts->SetAltParameters( *mc->GetSnapshot() );
   

   ToyMCSampler* toymcs = configureToyMCSampler(mc, data, plts);
   //ToyMCSampler* toymcs = configureToyMCImportanceSampler(mc, data, plts, impPoints, adaptiveNumImpPoints);
   toymcs->AddTestStatistic( slrts );
   

   // Since this tool needs to throw toy MC the PDF needs to be
   // extended or the tool needs to know how many entries in a dataset
   // per pseudo experiment.
   // In the 'number counting form' where the entries in the dataset
   // are counts, and not values of discriminating variables, the
   // datasets typically only have one entry and the PDF is not
   // extended.
   if (!mc->GetPdf()->canBeExtended()) {
      if (data->numEntries() == 1) {
         toymcs->SetNEventsPerToy(1);
      } else cout << "Not sure what to do about this model" << endl;
   }

   // We can use PROOF to speed things along in parallel
   //ProofConfig pc(*w, 144, "headprv", false);
   //ProofConfig pc(*w, 1000, "localhost", false);
   ProofConfig pc(*w, 2, "", false);
   //ProofConfig pc(*w, 144, "skreiss@localhost:3000", false);
   //toymcs.SetProofConfig(&pc);    // enable proof


   // instantiate the calculator
   FrequentistCalculator freqCalc(*data, *mc, *mcNull, toymcs);
   freqCalc.SetToys( toys,0 ); // null toys, alt toys

   //////////////////////////////////////////
   // unconditional ensemble, but configure for importance sampl to get weights
   // get result
   
   HypoTestResult* freqCalcResult = freqCalc.GetHypoTest();
   freqCalcResult->SetName( "HypoTestCalculator_result" );
   freqCalcResult->GetNullDistribution()->SetTitle("b-only, with importance sampling");
   freqCalcResult->SetAltDistribution(NULL);
   freqCalcResult->Print();


   cout << "Testing access to detailed output" << endl;
   freqCalcResult->GetNullDetailedOutput()->Print("v");
   cout << "Now get the first element" << endl;
   freqCalcResult->GetNullDetailedOutput()->get(0)->Print("v");
   cout << "which data store are you?" << endl;
   cout << freqCalcResult->GetNullDetailedOutput()->store()->IsA()->GetName() << endl;
   freqCalcResult->GetNullDetailedOutput()->store()->Print("v");


   double pvalue = freqCalcResult->NullPValue();
   cout << endl << "p-value: " << pvalue << endl;


   mn_t->Stop();
   cout << "total CPU time: " << mn_t->CpuTime() << endl;
   cout << "total real time: " << mn_t->RealTime() << endl;



   RooWorkspace ows( "ToysOutput" );
   ows.import( *freqCalcResult );
   ows.import( *mn_t, "time" );
   cout << "Writing file: " << ofile << endl;
   ows.writeToFile( ofile, true );


   return pvalue;
}


